package dismock

import (
	"net/http"
	"net/url"
	"testing"

	"github.com/diamondburned/arikawa/v3/api"
	"github.com/diamondburned/arikawa/v3/discord"
	"github.com/gorilla/schema"
	"github.com/stretchr/testify/assert"

	"github.com/mavolin/dismock/v3/internal/check"
)

// Code generated by tools/codegen/mock. DO NOT EDIT.

// =============================================================================
// application.go
// =====================================================================================

// Commands mocks api.Client.Commands.
func (m *Mocker) Commands(appID discord.AppID, _ret []discord.Command) {
	if _ret == nil {
		_ret = []discord.Command{}
	}

	m.MockAPI("Commands", http.MethodGet, "applications/"+appID.String()+"/commands",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// Command mocks api.Client.Command.
func (m *Mocker) Command(_ret discord.Command) {
	m.MockAPI("Command", http.MethodGet, "applications/"+_ret.AppID.String()+"/commands/"+_ret.ID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// CreateCommand mocks api.Client.CreateCommand.
func (m *Mocker) CreateCommand(data api.CreateCommandData, _ret discord.Command) {
	m.MockAPI("CreateCommand", http.MethodPost, "applications/"+_ret.AppID.String()+"/commands",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.WriteJSON(_t, _w, _ret)
		})
}

// EditCommand mocks api.Client.EditCommand.
func (m *Mocker) EditCommand(data api.CreateCommandData, _ret discord.Command) {
	m.MockAPI("EditCommand", http.MethodPatch, "applications/"+_ret.AppID.String()+"/commands/"+_ret.ID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.WriteJSON(_t, _w, _ret)
		})
}

// DeleteCommand mocks api.Client.DeleteCommand.
func (m *Mocker) DeleteCommand(appID discord.AppID, commandID discord.CommandID) {
	m.MockAPI("DeleteCommand", http.MethodDelete, "applications/"+appID.String()+"/commands/"+commandID.String(), nil)
}

// BulkOverwriteCommands mocks api.Client.BulkOverwriteCommands.
func (m *Mocker) BulkOverwriteCommands(appID discord.AppID, commands []discord.Command, _ret []discord.Command) {
	if _ret == nil {
		_ret = []discord.Command{}
	}

	m.MockAPI("BulkOverwriteCommands", http.MethodPut, "applications/"+appID.String()+"/commands",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, commands, _r.Body)

			check.WriteJSON(_t, _w, _ret)
		})
}

// GuildCommands mocks api.Client.GuildCommands.
func (m *Mocker) GuildCommands(appID discord.AppID, guildID discord.GuildID, _ret []discord.Command) {
	if _ret == nil {
		_ret = []discord.Command{}
	}

	m.MockAPI("GuildCommands", http.MethodGet, "applications/"+appID.String()+"/guilds/"+guildID.String()+"/commands",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// GuildCommand mocks api.Client.GuildCommand.
func (m *Mocker) GuildCommand(_ret discord.Command) {
	m.MockAPI("GuildCommand", http.MethodGet, "applications/"+_ret.AppID.String()+"/guilds/"+_ret.GuildID.String()+"/commands/"+_ret.ID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// CreateGuildCommand mocks api.Client.CreateGuildCommand.
func (m *Mocker) CreateGuildCommand(data api.CreateCommandData, _ret discord.Command) {
	m.MockAPI("CreateGuildCommand", http.MethodPost, "applications/"+_ret.AppID.String()+"/guilds/"+_ret.GuildID.String()+"/commands",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.WriteJSON(_t, _w, _ret)
		})
}

// EditGuildCommand mocks api.Client.EditGuildCommand.
func (m *Mocker) EditGuildCommand(data api.CreateCommandData, _ret discord.Command) {
	m.MockAPI("EditGuildCommand", http.MethodPatch, "applications/"+_ret.AppID.String()+"/guilds/"+_ret.GuildID.String()+"/commands/"+_ret.ID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.WriteJSON(_t, _w, _ret)
		})
}

// DeleteGuildCommand mocks api.Client.DeleteGuildCommand.
func (m *Mocker) DeleteGuildCommand(appID discord.AppID, guildID discord.GuildID, commandID discord.CommandID) {
	m.MockAPI("DeleteGuildCommand", http.MethodDelete, "applications/"+appID.String()+"/guilds/"+guildID.String()+"/commands/"+commandID.String(), nil)
}

// BulkOverwriteGuildCommands mocks api.Client.BulkOverwriteGuildCommands.
func (m *Mocker) BulkOverwriteGuildCommands(appID discord.AppID, guildID discord.GuildID, commands []discord.Command, _ret []discord.Command) {
	if _ret == nil {
		_ret = []discord.Command{}
	}

	m.MockAPI("BulkOverwriteGuildCommands", http.MethodPut, "applications/"+appID.String()+"/guilds/"+guildID.String()+"/commands",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, commands, _r.Body)

			check.WriteJSON(_t, _w, _ret)
		})
}

// GuildCommandPermissions mocks api.Client.GuildCommandPermissions.
func (m *Mocker) GuildCommandPermissions(appID discord.AppID, guildID discord.GuildID, _ret []discord.GuildCommandPermissions) {
	if _ret == nil {
		_ret = []discord.GuildCommandPermissions{}
	}

	m.MockAPI("GuildCommandPermissions", http.MethodGet, "applications/"+appID.String()+"/guilds/"+guildID.String()+"/commands/permissions",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// CommandPermissions mocks api.Client.CommandPermissions.
func (m *Mocker) CommandPermissions(_ret discord.GuildCommandPermissions) {
	m.MockAPI("CommandPermissions", http.MethodGet, "applications/"+_ret.AppID.String()+"/guilds/"+_ret.GuildID.String()+"/commands/"+_ret.ID.String()+"/permissions",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// EditCommandPermissions mocks api.Client.EditCommandPermissions.
func (m *Mocker) EditCommandPermissions(permissions []discord.CommandPermissions, _ret discord.GuildCommandPermissions) {
	m.MockAPI("EditCommandPermissions", http.MethodPut, "applications/"+_ret.AppID.String()+"/guilds/"+_ret.GuildID.String()+"/commands/"+_ret.ID.String()+"/permissions",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			_body := struct {
				Permissions []discord.CommandPermissions `json:"permissions"`
			}{
				Permissions: permissions,
			}

			check.JSON(_t, _body, _r.Body)

			check.WriteJSON(_t, _w, _ret)
		})
}

// BatchEditCommandPermissions mocks api.Client.BatchEditCommandPermissions.
func (m *Mocker) BatchEditCommandPermissions(appID discord.AppID, guildID discord.GuildID, data []api.BatchEditCommandPermissionsData, _ret []discord.GuildCommandPermissions) {
	if _ret == nil {
		_ret = []discord.GuildCommandPermissions{}
	}

	m.MockAPI("BatchEditCommandPermissions", http.MethodPut, "applications/"+appID.String()+"/guilds/"+guildID.String()+"/commands/permissions",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.WriteJSON(_t, _w, _ret)
		})
}

// =============================================================================
// channel.go
// =====================================================================================

// Channels mocks api.Client.Channels.
func (m *Mocker) Channels(guildID discord.GuildID, _ret []discord.Channel) {
	if _ret == nil {
		_ret = []discord.Channel{}
	}

	m.MockAPI("Channels", http.MethodGet, "guilds/"+guildID.String()+"/channels",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// CreateChannel mocks api.Client.CreateChannel.
func (m *Mocker) CreateChannel(data api.CreateChannelData, _ret discord.Channel) {
	m.MockAPI("CreateChannel", http.MethodPost, "guilds/"+_ret.GuildID.String()+"/channels",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.Header(_t, data.Header(), _r.Header)

			check.WriteJSON(_t, _w, _ret)
		})
}

// MoveChannels mocks api.Client.MoveChannels.
func (m *Mocker) MoveChannels(guildID discord.GuildID, data api.MoveChannelsData) {
	m.MockAPI("MoveChannels", http.MethodPatch, "guilds/"+guildID.String()+"/channels",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.Header(_t, data.Header(), _r.Header)
		})
}

// Channel mocks api.Client.Channel.
func (m *Mocker) Channel(_ret discord.Channel) {
	m.MockAPI("Channel", http.MethodGet, "channels/"+_ret.ID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// ModifyChannel mocks api.Client.ModifyChannel.
func (m *Mocker) ModifyChannel(channelID discord.ChannelID, data api.ModifyChannelData) {
	m.MockAPI("ModifyChannel", http.MethodPatch, "channels/"+channelID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.Header(_t, data.Header(), _r.Header)
		})
}

// DeleteChannel mocks api.Client.DeleteChannel.
func (m *Mocker) DeleteChannel(channelID discord.ChannelID, reason api.AuditLogReason) {
	m.MockAPI("DeleteChannel", http.MethodDelete, "channels/"+channelID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.Header(_t, reason.Header(), _r.Header)
		})
}

// EditChannelPermission mocks api.Client.EditChannelPermission.
func (m *Mocker) EditChannelPermission(channelID discord.ChannelID, overwriteID discord.Snowflake, data api.EditChannelPermissionData) {
	m.MockAPI("EditChannelPermission", http.MethodPut, "channels/"+channelID.String()+"/permissions/"+overwriteID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.Header(_t, data.Header(), _r.Header)
		})
}

// DeleteChannelPermission mocks api.Client.DeleteChannelPermission.
func (m *Mocker) DeleteChannelPermission(channelID discord.ChannelID, overwriteID discord.Snowflake, reason api.AuditLogReason) {
	m.MockAPI("DeleteChannelPermission", http.MethodDelete, "channels/"+channelID.String()+"/permissions/"+overwriteID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.Header(_t, reason.Header(), _r.Header)
		})
}

// Typing mocks api.Client.Typing.
func (m *Mocker) Typing(channelID discord.ChannelID) {
	m.MockAPI("Typing", http.MethodPost, "channels/"+channelID.String()+"/typing", nil)
}

// PinnedMessages mocks api.Client.PinnedMessages.
func (m *Mocker) PinnedMessages(channelID discord.ChannelID, _ret []discord.Message) {
	if _ret == nil {
		_ret = []discord.Message{}
	}

	m.MockAPI("PinnedMessages", http.MethodGet, "channels/"+channelID.String()+"/pins",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// PinMessage mocks api.Client.PinMessage.
func (m *Mocker) PinMessage(channelID discord.ChannelID, messageID discord.MessageID, reason api.AuditLogReason) {
	m.MockAPI("PinMessage", http.MethodPut, "channels/"+channelID.String()+"/pins/"+messageID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.Header(_t, reason.Header(), _r.Header)
		})
}

// UnpinMessage mocks api.Client.UnpinMessage.
func (m *Mocker) UnpinMessage(channelID discord.ChannelID, messageID discord.MessageID, reason api.AuditLogReason) {
	m.MockAPI("UnpinMessage", http.MethodDelete, "channels/"+channelID.String()+"/pins/"+messageID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.Header(_t, reason.Header(), _r.Header)
		})
}

// AddRecipient mocks api.Client.AddRecipient.
func (m *Mocker) AddRecipient(channelID discord.ChannelID, userID discord.UserID, accessToken string, nickname string) {
	m.MockAPI("AddRecipient", http.MethodPut, "channels/"+channelID.String()+"/recipients/"+userID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			_body := struct {
				AccessToken string `json:"access_token"`
				Nickname    string `json:"nickname"`
			}{
				AccessToken: accessToken,
				Nickname:    nickname,
			}

			check.JSON(_t, _body, _r.Body)
		})
}

// RemoveRecipient mocks api.Client.RemoveRecipient.
func (m *Mocker) RemoveRecipient(channelID discord.ChannelID, userID discord.UserID) {
	m.MockAPI("RemoveRecipient", http.MethodDelete, "channels/"+channelID.String()+"/recipients/"+userID.String(), nil)
}

// StartThreadWithMessage mocks api.Client.StartThreadWithMessage.
func (m *Mocker) StartThreadWithMessage(messageID discord.MessageID, data api.StartThreadData, _ret discord.Channel) {
	m.MockAPI("StartThreadWithMessage", http.MethodPost, "channels/"+_ret.ParentID.String()+"/messages/"+messageID.String()+"/threads",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.Header(_t, data.Header(), _r.Header)

			check.WriteJSON(_t, _w, _ret)
		})
}

// StartThreadWithoutMessage mocks api.Client.StartThreadWithoutMessage.
func (m *Mocker) StartThreadWithoutMessage(data api.StartThreadData, _ret discord.Channel) {
	m.MockAPI("StartThreadWithoutMessage", http.MethodPost, "channels/"+_ret.ParentID.String()+"/threads",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.Header(_t, data.Header(), _r.Header)

			check.WriteJSON(_t, _w, _ret)
		})
}

// JoinThread mocks api.Client.JoinThread.
func (m *Mocker) JoinThread(threadID discord.ChannelID) {
	m.MockAPI("JoinThread", http.MethodPut, "channels/"+threadID.String()+"/thread-members/@me", nil)
}

// AddThreadMember mocks api.Client.AddThreadMember.
func (m *Mocker) AddThreadMember(threadID discord.ChannelID, userID discord.UserID) {
	m.MockAPI("AddThreadMember", http.MethodPut, "channels/"+threadID.String()+"/thread-members/"+userID.String(), nil)
}

// LeaveThread mocks api.Client.LeaveThread.
func (m *Mocker) LeaveThread(threadID discord.ChannelID) {
	m.MockAPI("LeaveThread", http.MethodDelete, "channels/"+threadID.String()+"/thread-members/@me", nil)
}

// RemoveThreadMember mocks api.Client.RemoveThreadMember.
func (m *Mocker) RemoveThreadMember(threadID discord.ChannelID, userID discord.UserID) {
	m.MockAPI("RemoveThreadMember", http.MethodDelete, "channels/"+threadID.String()+"/thread-members/"+userID.String(), nil)
}

// ThreadMembers mocks api.Client.ThreadMembers.
func (m *Mocker) ThreadMembers(threadID discord.ChannelID, _ret []discord.ThreadMember) {
	if _ret == nil {
		_ret = []discord.ThreadMember{}
	}

	m.MockAPI("ThreadMembers", http.MethodGet, "channels/"+threadID.String()+"/thread-members",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// ActiveThreads mocks api.Client.ActiveThreads.
func (m *Mocker) ActiveThreads(guildID discord.GuildID, _ret []api.ActiveThread) {
	if _ret == nil {
		_ret = []api.ActiveThread{}
	}

	m.MockAPI("ActiveThreads", http.MethodGet, "guilds/"+guildID.String()+"/threads/active",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// PublicArchivedThreadsBefore mocks api.Client.PublicArchivedThreadsBefore.
func (m *Mocker) PublicArchivedThreadsBefore(channelID discord.ChannelID, before discord.Timestamp, limit uint, _ret []api.ArchivedThread) {
	if _ret == nil {
		_ret = []api.ArchivedThread{}
	}

	m.MockAPI("PublicArchivedThreadsBefore", http.MethodGet, "channels/"+channelID.String()+"/threads/archived/public",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			_params := struct {
				Before string `schema:"before"`
				Limit  uint   `schema:"limit"`
			}{
				Limit: limit,
			}

			if before.IsValid() {
				_params.Before = before.Format(discord.TimestampFormat)
			}

			var _values url.Values
			err := schema.NewEncoder().Encode(_params, _values)
			assert.NoError(_t, err)

			check.Query(_t, _values, _r.URL.Query())

			check.WriteJSON(_t, _w, _ret)
		})
}

// PrivateArchivedThreadsBefore mocks api.Client.PrivateArchivedThreadsBefore.
func (m *Mocker) PrivateArchivedThreadsBefore(channelID discord.ChannelID, before discord.Timestamp, limit uint, _ret []api.ArchivedThread) {
	if _ret == nil {
		_ret = []api.ArchivedThread{}
	}

	m.MockAPI("PrivateArchivedThreadsBefore", http.MethodGet, "channels/"+channelID.String()+"/threads/archived/private",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			_params := struct {
				Before string `schema:"before"`
				Limit  uint   `schema:"limit"`
			}{
				Limit: limit,
			}

			if before.IsValid() {
				_params.Before = before.Format(discord.TimestampFormat)
			}

			var _values url.Values
			err := schema.NewEncoder().Encode(_params, _values)
			assert.NoError(_t, err)

			check.Query(_t, _values, _r.URL.Query())

			check.WriteJSON(_t, _w, _ret)
		})
}

// JoinedPrivateArchivedThreadsBefore mocks api.Client.JoinedPrivateArchivedThreadsBefore.
func (m *Mocker) JoinedPrivateArchivedThreadsBefore(channelID discord.ChannelID, before discord.Timestamp, limit uint, _ret []api.ArchivedThread) {
	if _ret == nil {
		_ret = []api.ArchivedThread{}
	}

	m.MockAPI("JoinedPrivateArchivedThreadsBefore", http.MethodGet, "channels/"+channelID.String()+"/users/@me/threads/archived/private",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			_params := struct {
				Before string `schema:"before"`
				Limit  uint   `schema:"limit"`
			}{
				Limit: limit,
			}

			if before.IsValid() {
				_params.Before = before.Format(discord.TimestampFormat)
			}

			var _values url.Values
			err := schema.NewEncoder().Encode(_params, _values)
			assert.NoError(_t, err)

			check.Query(_t, _values, _r.URL.Query())

			check.WriteJSON(_t, _w, _ret)
		})
}

// =============================================================================
// emoji.go
// =====================================================================================

// Emojis mocks api.Client.Emojis.
func (m *Mocker) Emojis(guildID discord.GuildID, _ret []discord.Emoji) {
	if _ret == nil {
		_ret = []discord.Emoji{}
	}

	m.MockAPI("Emojis", http.MethodGet, "guilds/"+guildID.String()+"/emojis",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// Emoji mocks api.Client.Emoji.
func (m *Mocker) Emoji(guildID discord.GuildID, _ret discord.Emoji) {
	m.MockAPI("Emoji", http.MethodGet, "guilds/"+guildID.String()+"/emojis/"+_ret.ID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// CreateEmoji mocks api.Client.CreateEmoji.
func (m *Mocker) CreateEmoji(guildID discord.GuildID, data api.CreateEmojiData, _ret discord.Emoji) {
	m.MockAPI("CreateEmoji", http.MethodPost, "guilds/"+guildID.String()+"/emojis",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.Header(_t, data.Header(), _r.Header)

			check.WriteJSON(_t, _w, _ret)
		})
}

// ModifyEmoji mocks api.Client.ModifyEmoji.
func (m *Mocker) ModifyEmoji(guildID discord.GuildID, emojiID discord.EmojiID, data api.ModifyEmojiData) {
	m.MockAPI("ModifyEmoji", http.MethodPatch, "guilds/"+guildID.String()+"/emojis/"+emojiID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.Header(_t, data.Header(), _r.Header)
		})
}

// DeleteEmoji mocks api.Client.DeleteEmoji.
func (m *Mocker) DeleteEmoji(guildID discord.GuildID, emojiID discord.EmojiID, reason api.AuditLogReason) {
	m.MockAPI("DeleteEmoji", http.MethodDelete, "guilds/"+guildID.String()+"/emojis/"+emojiID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.Header(_t, reason.Header(), _r.Header)
		})
}

// =============================================================================
// guild.go
// =====================================================================================

// CreateGuild mocks api.Client.CreateGuild.
func (m *Mocker) CreateGuild(data api.CreateGuildData, _ret discord.Guild) {
	m.MockAPI("CreateGuild", http.MethodPost, "guilds",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.WriteJSON(_t, _w, _ret)
		})
}

// Guild mocks api.Client.Guild.
func (m *Mocker) Guild(_ret discord.Guild) {
	m.MockAPI("Guild", http.MethodGet, "guilds/"+_ret.ID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// GuildPreview mocks api.Client.GuildPreview.
func (m *Mocker) GuildPreview(_ret discord.GuildPreview) {
	m.MockAPI("GuildPreview", http.MethodGet, "guilds/"+_ret.ID.String()+"/preview",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// GuildWithCount mocks api.Client.GuildWithCount.
func (m *Mocker) GuildWithCount(_ret discord.Guild) {
	m.MockAPI("GuildWithCount", http.MethodGet, "guilds/"+_ret.ID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			_params := struct {
				WithCounts bool `schema:"with_counts"`
			}{
				WithCounts: true,
			}

			var _values url.Values
			err := schema.NewEncoder().Encode(_params, _values)
			assert.NoError(_t, err)

			check.Query(_t, _values, _r.URL.Query())

			check.WriteJSON(_t, _w, _ret)
		})
}

// LeaveGuild mocks api.Client.LeaveGuild.
func (m *Mocker) LeaveGuild(id discord.GuildID) {
	m.MockAPI("LeaveGuild", http.MethodDelete, "users/@me"+"/guilds/"+id.String(), nil)
}

// ModifyGuild mocks api.Client.ModifyGuild.
func (m *Mocker) ModifyGuild(data api.ModifyGuildData, _ret discord.Guild) {
	m.MockAPI("ModifyGuild", http.MethodPatch, "guilds/"+_ret.ID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.Header(_t, data.Header(), _r.Header)

			check.WriteJSON(_t, _w, _ret)
		})
}

// DeleteGuild mocks api.Client.DeleteGuild.
func (m *Mocker) DeleteGuild(id discord.GuildID) {
	m.MockAPI("DeleteGuild", http.MethodDelete, "guilds/"+id.String(), nil)
}

// VoiceRegionsGuild mocks api.Client.VoiceRegionsGuild.
func (m *Mocker) VoiceRegionsGuild(guildID discord.GuildID, _ret []discord.VoiceRegion) {
	if _ret == nil {
		_ret = []discord.VoiceRegion{}
	}

	m.MockAPI("VoiceRegionsGuild", http.MethodGet, "guilds/"+guildID.String()+"/regions",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// AuditLog mocks api.Client.AuditLog.
func (m *Mocker) AuditLog(guildID discord.GuildID, data api.AuditLogData, _ret discord.AuditLog) {
	m.MockAPI("AuditLog", http.MethodGet, "guilds/"+guildID.String()+"/audit-logs",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			var _values url.Values
			err := schema.NewEncoder().Encode(data, _values)
			assert.NoError(_t, err)

			check.Query(_t, _values, _r.URL.Query())

			check.WriteJSON(_t, _w, _ret)
		})
}

// Integrations mocks api.Client.Integrations.
func (m *Mocker) Integrations(guildID discord.GuildID, _ret []discord.Integration) {
	if _ret == nil {
		_ret = []discord.Integration{}
	}

	m.MockAPI("Integrations", http.MethodGet, "guilds/"+guildID.String()+"/integrations",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// AttachIntegration mocks api.Client.AttachIntegration.
func (m *Mocker) AttachIntegration(guildID discord.GuildID, integrationID discord.IntegrationID, integrationType discord.Service) {
	m.MockAPI("AttachIntegration", http.MethodPost, "guilds/"+guildID.String()+"/integrations",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			_body := struct {
				Type discord.Service       `json:"type"`
				Id   discord.IntegrationID `json:"id"`
			}{
				Type: integrationType,
				Id:   integrationID,
			}

			check.JSON(_t, _body, _r.Body)
		})
}

// ModifyIntegration mocks api.Client.ModifyIntegration.
func (m *Mocker) ModifyIntegration(guildID discord.GuildID, integrationID discord.IntegrationID, data api.ModifyIntegrationData) {
	m.MockAPI("ModifyIntegration", http.MethodPatch, "guilds/"+guildID.String()+"/integrations/"+integrationID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)
		})
}

// SyncIntegration mocks api.Client.SyncIntegration.
func (m *Mocker) SyncIntegration(guildID discord.GuildID, integrationID discord.IntegrationID) {
	m.MockAPI("SyncIntegration", http.MethodPost, "guilds/"+guildID.String()+"/integrations/"+integrationID.String()+"/sync", nil)
}

// GuildWidgetSettings mocks api.Client.GuildWidgetSettings.
func (m *Mocker) GuildWidgetSettings(guildID discord.GuildID, _ret discord.GuildWidgetSettings) {
	m.MockAPI("GuildWidgetSettings", http.MethodGet, "guilds/"+guildID.String()+"/widget",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// ModifyGuildWidget mocks api.Client.ModifyGuildWidget.
func (m *Mocker) ModifyGuildWidget(guildID discord.GuildID, data api.ModifyGuildWidgetData, _ret discord.GuildWidgetSettings) {
	m.MockAPI("ModifyGuildWidget", http.MethodPatch, "guilds/"+guildID.String()+"/widget",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.Header(_t, data.Header(), _r.Header)

			check.WriteJSON(_t, _w, _ret)
		})
}

// GuildWidget mocks api.Client.GuildWidget.
func (m *Mocker) GuildWidget(guildID discord.GuildID, _ret discord.GuildWidget) {
	m.MockAPI("GuildWidget", http.MethodGet, "guilds/"+guildID.String()+"/widget.json",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// GuildVanityInvite mocks api.Client.GuildVanityInvite.
func (m *Mocker) GuildVanityInvite(guildID discord.GuildID, _ret discord.Invite) {
	m.MockAPI("GuildVanityInvite", http.MethodGet, "guilds/"+guildID.String()+"/vanity-url",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// =============================================================================
// interaction.go
// =====================================================================================

// InteractionResponse mocks api.Client.InteractionResponse.
func (m *Mocker) InteractionResponse(appID discord.AppID, token string, _ret discord.Message) {
	m.MockAPI("InteractionResponse", http.MethodGet, "webhooks/"+appID.String()+"/"+token+"/messages/@original",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// EditInteractionResponse mocks api.Client.EditInteractionResponse.
func (m *Mocker) EditInteractionResponse(appID discord.AppID, token string, data api.EditInteractionResponseData, _ret discord.Message) {
	m.MockAPI("EditInteractionResponse", http.MethodPatch, "webhooks/"+appID.String()+"/"+token+"/messages/@original",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			if data.NeedsMultipart() {
				_files := data.Files
				data.Files = nil
				check.Multipart(_t, _r.Body, _r.Header, data, _files)
			} else {
				check.JSON(_t, data, _r.Body)
			}

			check.WriteJSON(_t, _w, _ret)
		})
}

// DeleteInteractionResponse mocks api.Client.DeleteInteractionResponse.
func (m *Mocker) DeleteInteractionResponse(appID discord.AppID, token string) {
	m.MockAPI("DeleteInteractionResponse", http.MethodDelete, "webhooks/"+appID.String()+"/"+token+"/messages/@original", nil)
}

// CreateInteractionFollowup mocks api.Client.CreateInteractionFollowup.
func (m *Mocker) CreateInteractionFollowup(appID discord.AppID, token string, data api.InteractionResponseData, _ret discord.Message) {
	m.MockAPI("CreateInteractionFollowup", http.MethodPost, "webhooks/"+appID.String()+"/"+token+"?",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			if data.NeedsMultipart() {
				_files := data.Files
				data.Files = nil
				check.Multipart(_t, _r.Body, _r.Header, data, _files)
			} else {
				check.JSON(_t, data, _r.Body)
			}

			check.WriteJSON(_t, _w, _ret)
		})
}

// EditInteractionFollowup mocks api.Client.EditInteractionFollowup.
func (m *Mocker) EditInteractionFollowup(appID discord.AppID, messageID discord.MessageID, token string, data api.EditInteractionResponseData, _ret discord.Message) {
	m.MockAPI("EditInteractionFollowup", http.MethodPatch, "webhooks/"+appID.String()+"/"+token+"/messages/"+messageID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			if data.NeedsMultipart() {
				_files := data.Files
				data.Files = nil
				check.Multipart(_t, _r.Body, _r.Header, data, _files)
			} else {
				check.JSON(_t, data, _r.Body)
			}

			check.WriteJSON(_t, _w, _ret)
		})
}

// DeleteInteractionFollowup mocks api.Client.DeleteInteractionFollowup.
func (m *Mocker) DeleteInteractionFollowup(appID discord.AppID, messageID discord.MessageID, token string) {
	m.MockAPI("DeleteInteractionFollowup", http.MethodDelete, "webhooks/"+appID.String()+"/"+token+"/messages/"+messageID.String(), nil)
}

// =============================================================================
// invite.go
// =====================================================================================

// Invite mocks api.Client.Invite.
func (m *Mocker) Invite(_ret discord.Invite) {
	m.MockAPI("Invite", http.MethodGet, "invites/"+_ret.Code,
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// InviteWithCounts mocks api.Client.InviteWithCounts.
func (m *Mocker) InviteWithCounts(_ret discord.Invite) {
	m.MockAPI("InviteWithCounts", http.MethodGet, "invites/"+_ret.Code,
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			_params := struct {
				WithCounts bool `schema:"with_counts"`
			}{
				WithCounts: true,
			}

			var _values url.Values
			err := schema.NewEncoder().Encode(_params, _values)
			assert.NoError(_t, err)

			check.Query(_t, _values, _r.URL.Query())

			check.WriteJSON(_t, _w, _ret)
		})
}

// ChannelInvites mocks api.Client.ChannelInvites.
func (m *Mocker) ChannelInvites(channelID discord.ChannelID, _ret []discord.Invite) {
	if _ret == nil {
		_ret = []discord.Invite{}
	}

	m.MockAPI("ChannelInvites", http.MethodGet, "channels/"+channelID.String()+"/invites",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// GuildInvites mocks api.Client.GuildInvites.
func (m *Mocker) GuildInvites(guildID discord.GuildID, _ret []discord.Invite) {
	if _ret == nil {
		_ret = []discord.Invite{}
	}

	m.MockAPI("GuildInvites", http.MethodGet, "guilds/"+guildID.String()+"/invites",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// CreateInvite mocks api.Client.CreateInvite.
func (m *Mocker) CreateInvite(channelID discord.ChannelID, data api.CreateInviteData, _ret discord.Invite) {
	m.MockAPI("CreateInvite", http.MethodPost, "channels/"+channelID.String()+"/invites",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.Header(_t, data.Header(), _r.Header)

			check.WriteJSON(_t, _w, _ret)
		})
}

// JoinInvite mocks api.Client.JoinInvite.
func (m *Mocker) JoinInvite(_ret api.JoinedInvite) {
	m.MockAPI("JoinInvite", http.MethodPost, "invites/"+_ret.Code,
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// DeleteInvite mocks api.Client.DeleteInvite.
func (m *Mocker) DeleteInvite(reason api.AuditLogReason, _ret discord.Invite) {
	m.MockAPI("DeleteInvite", http.MethodDelete, "invites/"+_ret.Code,
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.Header(_t, reason.Header(), _r.Header)

			check.WriteJSON(_t, _w, _ret)
		})
}

// =============================================================================
// login.go
// =====================================================================================

// Login mocks api.Client.Login.
func (m *Mocker) Login(email string, password string, _ret api.LoginResponse) {
	m.MockAPI("Login", http.MethodPost, "auth/login",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			_body := struct {
				Email    string `json:"email"`
				Password string `json:"password"`
			}{
				Email:    email,
				Password: password,
			}

			check.JSON(_t, _body, _r.Body)

			check.WriteJSON(_t, _w, _ret)
		})
}

// TOTP mocks api.Client.TOTP.
func (m *Mocker) TOTP(code string, ticket string, _ret api.LoginResponse) {
	m.MockAPI("TOTP", http.MethodPost, "auth/mfa/totp",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			_body := struct {
				Code   string `json:"code"`
				Ticket string `json:"ticket"`
			}{
				Code:   code,
				Ticket: ticket,
			}

			check.JSON(_t, _body, _r.Body)

			check.WriteJSON(_t, _w, _ret)
		})
}

// =============================================================================
// member.go
// =====================================================================================

// Member mocks api.Client.Member.
func (m *Mocker) Member(guildID discord.GuildID, _ret discord.Member) {
	m.MockAPI("Member", http.MethodGet, "guilds/"+guildID.String()+"/members/"+_ret.User.ID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// AddMember mocks api.Client.AddMember.
func (m *Mocker) AddMember(guildID discord.GuildID, data api.AddMemberData, _ret discord.Member) {
	m.MockAPI("AddMember", http.MethodPut, "guilds/"+guildID.String()+"/members/"+_ret.User.ID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.WriteJSON(_t, _w, _ret)
		})
}

// ModifyMember mocks api.Client.ModifyMember.
func (m *Mocker) ModifyMember(guildID discord.GuildID, userID discord.UserID, data api.ModifyMemberData) {
	m.MockAPI("ModifyMember", http.MethodPatch, "guilds/"+guildID.String()+"/members/"+userID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.Header(_t, data.Header(), _r.Header)
		})
}

// PruneCount mocks api.Client.PruneCount.
func (m *Mocker) PruneCount(guildID discord.GuildID, data api.PruneCountData, _ret uint) {
	m.MockAPI("PruneCount", http.MethodGet, "guilds/"+guildID.String()+"/prune",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			var _values url.Values
			err := schema.NewEncoder().Encode(data, _values)
			assert.NoError(_t, err)

			check.Query(_t, _values, _r.URL.Query())

			_wrappedResp := struct {
				Resp uint `json:"pruned"`
			}{Resp: _ret}
			check.WriteJSON(_t, _w, _wrappedResp)
		})
}

// Prune mocks api.Client.Prune.
func (m *Mocker) Prune(guildID discord.GuildID, data api.PruneData, _ret uint) {
	m.MockAPI("Prune", http.MethodPost, "guilds/"+guildID.String()+"/prune",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			var _values url.Values
			err := schema.NewEncoder().Encode(data, _values)
			assert.NoError(_t, err)

			check.Query(_t, _values, _r.URL.Query())

			check.Header(_t, data.Header(), _r.Header)

			_wrappedResp := struct {
				Resp uint `json:"pruned"`
			}{Resp: _ret}
			check.WriteJSON(_t, _w, _wrappedResp)
		})
}

// KickWithReason mocks api.Client.KickWithReason.
func (m *Mocker) KickWithReason(guildID discord.GuildID, userID discord.UserID, reason api.AuditLogReason) {
	m.MockAPI("KickWithReason", http.MethodDelete, "guilds/"+guildID.String()+"/members/"+userID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.Header(_t, reason.Header(), _r.Header)
		})
}

// Bans mocks api.Client.Bans.
func (m *Mocker) Bans(guildID discord.GuildID, _ret []discord.Ban) {
	if _ret == nil {
		_ret = []discord.Ban{}
	}

	m.MockAPI("Bans", http.MethodGet, "guilds/"+guildID.String()+"/bans",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// GetBan mocks api.Client.GetBan.
func (m *Mocker) GetBan(guildID discord.GuildID, _ret discord.Ban) {
	m.MockAPI("GetBan", http.MethodGet, "guilds/"+guildID.String()+"/bans/"+_ret.User.ID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// Ban mocks api.Client.Ban.
func (m *Mocker) Ban(guildID discord.GuildID, userID discord.UserID, data api.BanData) {
	m.MockAPI("Ban", http.MethodPut, "guilds/"+guildID.String()+"/bans/"+userID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			var _values url.Values
			err := schema.NewEncoder().Encode(data, _values)
			assert.NoError(_t, err)

			check.Query(_t, _values, _r.URL.Query())

			check.Header(_t, data.Header(), _r.Header)
		})
}

// Unban mocks api.Client.Unban.
func (m *Mocker) Unban(guildID discord.GuildID, userID discord.UserID, reason api.AuditLogReason) {
	m.MockAPI("Unban", http.MethodDelete, "guilds/"+guildID.String()+"/bans/"+userID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.Header(_t, reason.Header(), _r.Header)
		})
}

// =============================================================================
// message.go
// =====================================================================================

// Message mocks api.Client.Message.
func (m *Mocker) Message(_ret discord.Message) {
	m.MockAPI("Message", http.MethodGet, "channels/"+_ret.ChannelID.String()+"/messages/"+_ret.ID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// CrosspostMessage mocks api.Client.CrosspostMessage.
func (m *Mocker) CrosspostMessage(channelID discord.ChannelID, messageID discord.MessageID, _ret discord.Message) {
	m.MockAPI("CrosspostMessage", http.MethodPost, "channels/"+channelID.String()+"/messages/"+messageID.String()+"/crosspost",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// DeleteMessage mocks api.Client.DeleteMessage.
func (m *Mocker) DeleteMessage(channelID discord.ChannelID, messageID discord.MessageID, reason api.AuditLogReason) {
	m.MockAPI("DeleteMessage", http.MethodDelete, "channels/"+channelID.String()+"/messages/"+messageID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.Header(_t, reason.Header(), _r.Header)
		})
}

// =============================================================================
// message_reaction.go
// =====================================================================================

// React mocks api.Client.React.
func (m *Mocker) React(channelID discord.ChannelID, messageID discord.MessageID, emoji discord.APIEmoji) {
	m.MockAPI("React", http.MethodPut, "channels/"+channelID.String()+"/messages/"+messageID.String()+"/reactions/"+emoji.PathString()+"/@me", nil)
}

// DeleteReactions mocks api.Client.DeleteReactions.
func (m *Mocker) DeleteReactions(channelID discord.ChannelID, messageID discord.MessageID, emoji discord.APIEmoji) {
	m.MockAPI("DeleteReactions", http.MethodDelete, "channels/"+channelID.String()+"/messages/"+messageID.String()+"/reactions/"+emoji.PathString(), nil)
}

// DeleteAllReactions mocks api.Client.DeleteAllReactions.
func (m *Mocker) DeleteAllReactions(channelID discord.ChannelID, messageID discord.MessageID) {
	m.MockAPI("DeleteAllReactions", http.MethodDelete, "channels/"+channelID.String()+"/messages/"+messageID.String()+"/reactions", nil)
}

// =============================================================================
// role.go
// =====================================================================================

// AddRole mocks api.Client.AddRole.
func (m *Mocker) AddRole(guildID discord.GuildID, userID discord.UserID, roleID discord.RoleID, data api.AddRoleData) {
	m.MockAPI("AddRole", http.MethodPut, "guilds/"+guildID.String()+"/members/"+userID.String()+"/roles/"+roleID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.Header(_t, data.Header(), _r.Header)
		})
}

// RemoveRole mocks api.Client.RemoveRole.
func (m *Mocker) RemoveRole(guildID discord.GuildID, userID discord.UserID, roleID discord.RoleID, reason api.AuditLogReason) {
	m.MockAPI("RemoveRole", http.MethodDelete, "guilds/"+guildID.String()+"/members/"+userID.String()+"/roles/"+roleID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.Header(_t, reason.Header(), _r.Header)
		})
}

// Roles mocks api.Client.Roles.
func (m *Mocker) Roles(guildID discord.GuildID, _ret []discord.Role) {
	if _ret == nil {
		_ret = []discord.Role{}
	}

	m.MockAPI("Roles", http.MethodGet, "guilds/"+guildID.String()+"/roles",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// CreateRole mocks api.Client.CreateRole.
func (m *Mocker) CreateRole(guildID discord.GuildID, data api.CreateRoleData, _ret discord.Role) {
	m.MockAPI("CreateRole", http.MethodPost, "guilds/"+guildID.String()+"/roles",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.Header(_t, data.Header(), _r.Header)

			check.WriteJSON(_t, _w, _ret)
		})
}

// MoveRoles mocks api.Client.MoveRoles.
func (m *Mocker) MoveRoles(guildID discord.GuildID, data api.MoveRolesData, _ret []discord.Role) {
	if _ret == nil {
		_ret = []discord.Role{}
	}

	m.MockAPI("MoveRoles", http.MethodPatch, "guilds/"+guildID.String()+"/roles",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.Header(_t, data.Header(), _r.Header)

			check.WriteJSON(_t, _w, _ret)
		})
}

// ModifyRole mocks api.Client.ModifyRole.
func (m *Mocker) ModifyRole(guildID discord.GuildID, data api.ModifyRoleData, _ret discord.Role) {
	m.MockAPI("ModifyRole", http.MethodPatch, "guilds/"+guildID.String()+"/roles/"+_ret.ID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.Header(_t, data.Header(), _r.Header)

			check.WriteJSON(_t, _w, _ret)
		})
}

// DeleteRole mocks api.Client.DeleteRole.
func (m *Mocker) DeleteRole(guildID discord.GuildID, roleID discord.RoleID, reason api.AuditLogReason) {
	m.MockAPI("DeleteRole", http.MethodDelete, "guilds/"+guildID.String()+"/roles/"+roleID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.Header(_t, reason.Header(), _r.Header)
		})
}

// =============================================================================
// search.go
// =====================================================================================

// Search mocks api.Client.Search.
func (m *Mocker) Search(guildID discord.GuildID, data api.SearchData, _ret api.SearchResponse) {
	m.MockAPI("Search", http.MethodGet, "guilds/"+guildID.String()+"/messages/search",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			var _values url.Values
			err := schema.NewEncoder().Encode(data, _values)
			assert.NoError(_t, err)

			check.Query(_t, _values, _r.URL.Query())

			check.WriteJSON(_t, _w, _ret)
		})
}

// =============================================================================
// stage.go
// =====================================================================================

// CreateStageInstance mocks api.Client.CreateStageInstance.
func (m *Mocker) CreateStageInstance(data api.CreateStageInstanceData, _ret discord.StageInstance) {
	m.MockAPI("CreateStageInstance", http.MethodPost, "stage-instances/",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.Header(_t, data.Header(), _r.Header)

			check.WriteJSON(_t, _w, _ret)
		})
}

// UpdateStageInstance mocks api.Client.UpdateStageInstance.
func (m *Mocker) UpdateStageInstance(channelID discord.ChannelID, data api.UpdateStageInstanceData) {
	m.MockAPI("UpdateStageInstance", http.MethodPatch, "stage-instances/"+channelID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.Header(_t, data.Header(), _r.Header)
		})
}

// DeleteStageInstance mocks api.Client.DeleteStageInstance.
func (m *Mocker) DeleteStageInstance(channelID discord.ChannelID, reason api.AuditLogReason) {
	m.MockAPI("DeleteStageInstance", http.MethodDelete, "stage-instances/"+channelID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.Header(_t, reason.Header(), _r.Header)
		})
}

// =============================================================================
// user.go
// =====================================================================================

// User mocks api.Client.User.
func (m *Mocker) User(_ret discord.User) {
	m.MockAPI("User", http.MethodGet, "users/"+_ret.ID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// Me mocks api.Client.Me.
func (m *Mocker) Me(_ret discord.User) {
	m.MockAPI("Me", http.MethodGet, "users/@me",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// ModifyMe mocks api.Client.ModifyMe.
func (m *Mocker) ModifyMe(data api.ModifySelfData, _ret discord.User) {
	m.MockAPI("ModifyMe", http.MethodPatch, "users/@me",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.Header(_t, data.Header(), _r.Header)

			check.WriteJSON(_t, _w, _ret)
		})
}

// ChangeOwnNickname mocks api.Client.ChangeOwnNickname.
func (m *Mocker) ChangeOwnNickname(guildID discord.GuildID, nick string) {
	m.MockAPI("ChangeOwnNickname", http.MethodPatch, "guilds/"+guildID.String()+"/members/@me/nick",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			_body := struct {
				Nick string `json:"nick"`
			}{
				Nick: nick,
			}

			check.JSON(_t, _body, _r.Body)
		})
}

// PrivateChannels mocks api.Client.PrivateChannels.
func (m *Mocker) PrivateChannels(_ret []discord.Channel) {
	if _ret == nil {
		_ret = []discord.Channel{}
	}

	m.MockAPI("PrivateChannels", http.MethodGet, "users/@me"+"/channels",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// CreatePrivateChannel mocks api.Client.CreatePrivateChannel.
func (m *Mocker) CreatePrivateChannel(_ret discord.Channel) {
	m.MockAPI("CreatePrivateChannel", http.MethodPost, "users/@me"+"/channels",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			_body := struct {
				RecipientID discord.UserID `json:"recipient_id"`
			}{
				RecipientID: _ret.DMRecipients[0].ID,
			}

			check.JSON(_t, _body, _r.Body)

			check.WriteJSON(_t, _w, _ret)
		})
}

// UserConnections mocks api.Client.UserConnections.
func (m *Mocker) UserConnections(_ret []discord.Connection) {
	if _ret == nil {
		_ret = []discord.Connection{}
	}

	m.MockAPI("UserConnections", http.MethodGet, "users/@me"+"/connections",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// Note mocks api.Client.Note.
func (m *Mocker) Note(userID discord.UserID, _ret string) {
	m.MockAPI("Note", http.MethodGet, "users/@me"+"/notes/"+userID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// SetNote mocks api.Client.SetNote.
func (m *Mocker) SetNote(userID discord.UserID, note string) {
	m.MockAPI("SetNote", http.MethodPut, "users/@me"+"/notes/"+userID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			_body := struct {
				Note string `json:"note"`
			}{
				Note: note,
			}

			check.JSON(_t, _body, _r.Body)
		})
}

// SetRelationship mocks api.Client.SetRelationship.
func (m *Mocker) SetRelationship(userID discord.UserID, t discord.RelationshipType) {
	m.MockAPI("SetRelationship", http.MethodPut, "users/@me"+"/relationships/"+userID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			_body := struct {
				Type discord.RelationshipType `json:"type"`
			}{
				Type: t,
			}

			check.JSON(_t, _body, _r.Body)
		})
}

// DeleteRelationship mocks api.Client.DeleteRelationship.
func (m *Mocker) DeleteRelationship(userID discord.UserID) {
	m.MockAPI("DeleteRelationship", http.MethodDelete, "users/@me"+"/relationships/"+userID.String(), nil)
}

// =============================================================================
// webhook.go
// =====================================================================================

// CreateWebhook mocks api.Client.CreateWebhook.
func (m *Mocker) CreateWebhook(data api.CreateWebhookData, _ret discord.Webhook) {
	m.MockAPI("CreateWebhook", http.MethodPost, "channels/"+_ret.ChannelID.String()+"/webhooks",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.WriteJSON(_t, _w, _ret)
		})
}

// ChannelWebhooks mocks api.Client.ChannelWebhooks.
func (m *Mocker) ChannelWebhooks(channelID discord.ChannelID, _ret []discord.Webhook) {
	if _ret == nil {
		_ret = []discord.Webhook{}
	}

	m.MockAPI("ChannelWebhooks", http.MethodGet, "channels/"+channelID.String()+"/webhooks",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// GuildWebhooks mocks api.Client.GuildWebhooks.
func (m *Mocker) GuildWebhooks(guildID discord.GuildID, _ret []discord.Webhook) {
	if _ret == nil {
		_ret = []discord.Webhook{}
	}

	m.MockAPI("GuildWebhooks", http.MethodGet, "guilds/"+guildID.String()+"/webhooks",
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// Webhook mocks api.Client.Webhook.
func (m *Mocker) Webhook(_ret discord.Webhook) {
	m.MockAPI("Webhook", http.MethodGet, "webhooks/"+_ret.ID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.WriteJSON(_t, _w, _ret)
		})
}

// ModifyWebhook mocks api.Client.ModifyWebhook.
func (m *Mocker) ModifyWebhook(data api.ModifyWebhookData, _ret discord.Webhook) {
	m.MockAPI("ModifyWebhook", http.MethodPatch, "webhooks/"+_ret.ID.String(),
		func(_w http.ResponseWriter, _r *http.Request, _t *testing.T) {
			check.JSON(_t, data, _r.Body)

			check.WriteJSON(_t, _w, _ret)
		})
}

// DeleteWebhook mocks api.Client.DeleteWebhook.
func (m *Mocker) DeleteWebhook(webhookID discord.WebhookID) {
	m.MockAPI("DeleteWebhook", http.MethodDelete, "webhooks/"+webhookID.String(), nil)
}
